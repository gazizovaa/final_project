§
    °quhç5  ã                   óÌ   — d Z ddlZddlZddlZddlZddlZddlZddl mZm	Z	m
Z
m
Z
mZm
Z
mZmZmZ  G d„ d¦  «        Zd „ Zdd	œd
„Zd
„ Zd„ Zd
„ Zdd„Zd„ Zd„ Zd„ Zd„ Zdd„ZdS )a+  
Helper functions for managing the Matplotlib API.

This documentation is only relevant for Matplotlib developers, not for users.

.. warning::

    This module and its submodules are for internal use only.  Do not use them
    in your own code.  We may change the API at any time with no warning.

é    Né   )	Ú
deprecatedÚwarn_deprecatedÚrename_parameterÚdelete_parameterÚmake_keyword_onlyÚdeprecate_method_overrideÚdeprecate_privatize_attributeÚ'suppress_matplotlib_deprecation_warningÚMatplotlibDeprecationWarningc                   ó6   — e Zd ZdZdd„Zd„ Zed„ ¦   «         Z dS ) Ú
classpropertya$  
    Like `property`, but also triggers on access via the class, and it is the
    *class* that's passed as argument.

    Examples
    --------
    ::

        class C:
            @classproperty
            def foo(cls):
                return cls.__name__

        assert C.foo == "C"
    Nc                 ód   — || _         |€|t          d¦  «        ‚|| _        || _        || _        d S )Nz#classproperty only implements fget.)Ú_fgetÚ
ValueErrorÚfsetÚfdelÚ_doc)ÚselfÚfgetr   r   Údocs        úCD:\streamlit_app\venv\Lib\site-packages\matplotlib/_api/__init__.pyÚ__init__zclassproperty.__init__-   s<   € ØˆŒ
Ø
Ð
˜tÐ/ÝÐBÑCÔCÐCØˆŒ	ØˆŒ	àˆŒ	ˆ	ˆ	ó    c                 ó,   — |                       |¦  «        S ©N©r   )r   ÚinstanceÚowners      r   Ú __get__zclassproperty.__get__6   s   € ØzŠz˜%Ñ Ô Ð r   c                 ó   — | j         S r   r   )r   s    r   r   zclassproperty.fget9   s
   € àŒzÐr   )NNN)Ú__name__Ú
__module__Ú__qualname__Ú __doc__r   r    Úpropertyr   © r   r   r   r      s\   € € € € € ðð ð  ð  ð  ð  ð!ð !ð !ð ðð ñ „Xðð ð r   r   c             
   ól  ‡— t          d¦  «        Št          | t           ¦  «        r| fn| €‰fnt          ˆfd„| D ¦   «         ¦  «        } ˆfd„}|                     ¦   «         D ]Ñ\  }}t          || ¦  «        s¼g t	          || ¦  «        ¢}d|v r*|                     d¦  «         |                     d¦  «         t          d                     |t          |¦  «        dk    r)d  
                    |dd…         ¦  «        d	z   |d         z   n |d
          |t          |¦  «        ¦  «        ¦  «        ¦  «        ‚ŒÒdS )
a3  
    For each *key, value* pair in *kwargs*, check that *value* is an instance
    of one of *types*; if not, raise an appropriate TypeError.

    As a special case, a ``None`` entry in *types* is treated as NoneType.

    Examples
    --------
    >>> _api.check_isinstance((SomeClass, None), arg=arg)
    Nc              3   ó$   •K  — | ]
}|€‰n|V — Œ
d S r   r'   )Ú.0ÚtpÚ	none_types     €r   ú	<genexpr>z#check_isinstance.<locals>.<genexpr>O   s+   øè è € ÐCÐC°r  
99°ÐCÐCÐCÐCÐCÐCr   c                 óV   •— | ‰u rdn"| j         dk    r | j        n| j         › d| j        › S )NÚNoneÚbuiltinsú.)r#   r$   )r+   r,   s    €r   Ú	type_namez#check_isinstance.<locals>.type_nameQ   s=   ø€ Ø 	˜/˜/Ø(*¬
¸Ò(CÐ(CR”__Øœ
Ð9Ð9¨¬Ð9Ð9ð	;r   r/   z({!r} must be an instance of {}, not a {}r   ú, éÿÿÿÿz or r   )
ÚtypeÚ
isinstanceÚtupleÚitemsÚmapÚremoveÚappendÚ	TypeErrorÚformatÚlenÚjoin) ÚtypesÚkwargsr2   ÚkÚvÚnamesr,   s          @r   Úcheck_isinstancerE   A   sl  ø€ õ T‘
”
€IÝ# E­4Ñ0Ô0ð DˆeˆXˆXØ"˜]ˆiˆ\ˆ\Ý
ÐCÐCÐCÐC¸UÐCÑCÔCÑ
CÔ
Cð 
ð;ð ;ð ;ð ;ð ;ð
 —’‘”ð 
)ð 
)‰ˆˆ1Ý˜!˜UÑ#Ô#ð 
	)Ø,•c˜) UÑ+Ô+Ð,ˆEØ˜ˆˆØ—’˜VÑ$Ô$Ð$Ø—’˜VÑ$Ô$Ð$ÝØ:×AÒAØå˜5‘z”z A’~~ð —I’I˜e C R CœjÑ)Ô)¨FÑ2°U¸2´YÑ>Ð>Ø+0°¬8ØId 1™gœgÑ&Ô&ñ	(ô (ñ)ô )ð 
)ð

	)ð
)ð 
)r   T)Ú_print_supported_valuesc         	   
   óð   — |st          d¦  «        ‚|                     ¦   «         D ]O\  }}|| vrF|›d|› }|r.|dd                     t           t          | ¦  «        ¦  «        › z
  }t
          |¦  «        ‚ŒPdS )ak  
    For each *key, value* pair in *kwargs*, check that *value* is in *values*;
    if not, raise an appropriate ValueError.

    Parameters
    ----------
    values : iterable
        Sequence of values to check on.
    _print_supported_values : bool, default: True
        Whether to print *values* when raising ValueError.
    **kwargs : dict
        *key, value* pairs as keyword arguments to find in *values*.

    Raises
    ------
    ValueError
        If any *value* in *kwargs* is not found in *values*.

    Examples
    --------
    >>> _api.check_in_list(["foo", "bar"], arg=arg, other_arg=other_arg)
    zNo argument to check!ú is not a valid value for ú; supported values are r3   N)r<   r8   r?   r9   Úreprr   )ÚvaluesrF   rA   ÚkeyÚvalÚmsgs         r   Ú
check_in_listrO   d   s¡   € ð. ð 1ÝÐ/Ñ0Ô0Ð0Ø—L’L‘N”Nð "ð "‰ˆˆSØ
fÐ
Ð
ØÐ;Ð;°cÐ;Ð;ˆCØ&ð 
PØÐO°·²½3½tÀVÑ;LÔ;LÑ1MÔ1MÐOÐOÑOÝ˜S‘/”/Ð!ð	 ð"ð "r   c          
   
   óD  ‡— |                      ¦   «         D ]\  }}|j        }t          |¦  «        t          | ¦  «        k    s't           d„ t	          || ¦  «        D ¦   «         ¦  «        r´t
          t
          j         dd„ t
          j        ¦   «         D ¦   «         ¦  «        ¦  «        Šd 	                    ˆfd„| ddd …         D ¦   «         ddd …         ¦  «        }t          | ¦  «        dk    r|d	z
  }t          |›d
t          | ¦  «        › d
|› d|j        ›  ¦  «        ‚Œ
dS )
a¦  
    For each *key, value* pair in *kwargs*, check that *value* has the shape *shape*;
    if not, raise an appropriate ValueError.

    *None* in the shape is treated as a "free" size that can have any length.
    e.g. (None, 2) -> (N, 2)

    The values checked must be numpy arrays.

    Examples
    --------
    To check for (N, 2) shaped arrays

    >>> _api.check_shape((None, 2), arg=arg, other_arg=other_arg)
    c              3   ó0   K  — | ]\  }}||k    o|d uV — Œd S r   r'   )r*   ÚsÚts      r   r-   zcheck_shape.<locals>.<genexpr>™   s3   è è € ÐSÐS±D°A°qq˜A’vÐ/ !¨4 -ÐSÐSÐSÐSÐSÐSr   Ú NMLKJIHc              3   ó    K  — | ]	}d |› V — Œ
dS )ÚDNr'   )r*   Úis     r   r-   zcheck_shape.<locals>.<genexpr>œ   s(   è è € Ð4Ð4˜QQÐ4Ð4Ð4Ð4Ð4Ð4r   r3   c                 óP   •— g | ]"}|t          |¦  «        nt          ‰¦  «        ‘Œ#S r   )ÚstrÚnext)r*   ÚnÚ
dim_labelss     €r   ú
<listcomp>zcheck_shape.<locals>.<listcomp>   s?   ø€ ð $:ð $:ð $:Ø()ð /0¨m¥C¨¡F¤F FÅÀjÑAQÔAQð $:ð $:ð $:r   Nr4   r   ú,z	 must be zD with shape (z), but your input has shape )
r8   Úshaper>   ÚanyÚzipÚiterÚ	itertoolsÚchainÚcountr?   r   ) r_   rA   rB   rC   Ú
data_shapeÚ
text_shaper\   s          @r   Ú
check_shaperh   …   sj  ø€ ð  —’‘”ð ñ ‰ˆˆ1Ø”Wˆ
å
‰OŒOs 5™zœzÒ)Ð)ÝÐSÐS½CÀ
ÈEÑ<RÔ<RÐSÑSÔSÑSÔSð 
*åiœoØØ4Ð4¥)¤/Ñ"3Ô"3Ð4Ñ4Ô4ñ6ô 6ñ 7ô 7ˆJð Ÿšð $:ð $:ð $:ð $:Ø-2°4°4°R°4¬[ð$:ñ $:ô $:Ø:>¸$¸B¸$ô$@ñ Aô AˆJå5‰zŒz˜QŠˆØ˜cÑ!
åØð 6ð 6¥ U¡¤ð 6ð 6¸:ð 6ð 6Ø,-¬Gð6ð 6ñô ð 
ñ 
*ð ð r   c          
   
   ó"  — t          |¦  «        dk    rt          d¦  «        ‚|                     ¦   «         \  \  }}	 | |         S # t          $ r? t          |›d|› dd                     t
          t          | ¦  «        ¦  «        › ¦  «        d‚w xY w) zò
    *kwargs* must consist of a single *key, value* pair.  If *key* is in
    *mapping*, return ``mapping[value]``; else, raise an appropriate
    ValueError.

    Examples
    --------
    >>> _api.check_getitem({"foo": "bar"}, arg=arg)
    r   z-check_getitem takes a single keyword argumentrH   rI   r3   N) r>   r   r8   ÚKeyErrorr?   r9   rJ   )Ú mappingrA   rB   rC   s       r   Ú
check_getitemrl   ¨   s²   € õ 
ˆ6{„{aÒ Ð ÝÐHÑIÔIÐIØlŠl‰nŒnGF€Qˆð:ØqŒzÐøÝ
ð :ð :ð :ÝØð 
/ð 
/¨að 
/ð 
/ØyŠyT 7Ñ+Ô+Ñ,Ô,ð
/ð 
/ñ0ô 0à59ð	:ð:øøøs   ½ A ÁA	Bc                 óÂ   ‡ ‡‡— ‰ j         dk    sJ ‚d„ t          ‰ ¦  «                             ¦   «         D ¦   «         Š ‰ ¦   «         Št          j        ˆ ˆˆfd„¦   «         }|S )a
  
    Helper decorator for implementing module-level ``__getattr__`` as a class.

    This decorator must be used at the module toplevel as follows::

        @caching_module_getattr
        class __getattr__:  # The class *must* be named ``__getattr__``.
            @property  # Only properties are taken into account.
            def name(self): ...

    The ``__getattr__`` class will be replaced by a ``__getattr__``
    function such that trying to access ``name`` on the module will
    resolve the corresponding property (which may be decorated e.g. with
    ``_api.deprecated`` for deprecating module globals).  The properties are
    all implicitly cached.  Moreover, a suitable AttributeError is generated
    and raised if no property with the given name exists.
    Ú
__getattr__c                 óD   — i | ]\  }}t          |t          ¦  «        ¯||“ŒS r'   )r6   r&   )r*   ÚnameÚprops      r   ú
<dictcomp>z*caching_module_getattr.<locals>.<dictcomp>Ò   s<   € ð 
,ð 
,ð 
,™J˜D $Ý˜4¥Ñ*Ô*ð
,ˆT4ð 
,ð 
,ð 
,r   c                 óv   •— | ‰v r‰|                                ‰¦  «        S t          d‰j        ›d| ›¦  «        ‚)Nz module z has no attribute )r    ÚAttributeErrorr#   )rp   Úclsr   Úpropss    €€€r   rn   z+caching_module_getattr.<locals>.__getattr__Ö   sN   ø€ à
5ˆ=ˆ=Ø˜”;×&Ò& xÑ0Ô0Ð0ÝØBc”nÐBÐB¸$ÐBÐBñDô Dð 	Dr   )r"   Úvarsr8   Ú	functoolsÚcache)ru   rn   r   rv   s   ` @@r   Úcaching_module_getattrrz   ½   s   øøø€ ð& Œ<˜=Ò
(Ð
(Ð
(Ð
(ð
,ð 
,­$¨s©)¬)¯/ª/Ñ*;Ô*;ð 
,ñ 
,ô 
,€Eàˆs‰uŒu€Hå„_ðDð Dð Dð Dð Dð Dñ „_ðDð Ðr   c                 óò  ‡— ‰€t          j        t          | ¦  «        S ˆfd„}|                      ¦   «         D ]u\  }}d}dD ]W}||z   t	          ‰¦  «        v rAd}|D ]<}  |||z   ¦  «        }|| z   |_        d||z   › d |_        t          ‰|| z   |¦  «         Œ=ŒX|st          d|›¦  «        ‚Œvd	„ }	t          ‰d
i ¦  «        }
 |	|
¦  «         |	| ¦  «        z  }
|
rt          d
|
› ¦  «        ‚i |
¥| ¥‰_
        ‰S )aT  
    Class decorator for defining property aliases.

    Use as ::

        @_api.define_aliases({"property": ["alias", ...], ...})
        class C: ...

    For each property, if the corresponding ``get_property`` is defined in the
    class so far, an alias named ``get_alias`` will be defined; the same will
    be done for setters.  If neither the getter nor the setter exists, an
    exception will be raised.

    The alias map is stored as the ``_alias_map`` attribute on the class and
    can be used by `.normalize_kwargs` (which assumes that higher priority
    aliases come last).
    Nc                 ód   •‡ — t          j        t          ‰‰ ¦  «        ¦  «        ˆ fd„¦   «         }|S )Nc                 ó0   •—  t          | ‰¦  «        |i |¤ŽS r   )Ú getattr)r   ÚargsrA   rp   s      €r   Úmethodz2define_aliases.<locals>.make_alias.<locals>.methodö   s"   ø€ à&•7˜4 Ñ&Ô&¨Ð7°Ð7Ð7Ð7r   )rx   Úwrapsr~   )rp   r€   ru   s   ` €r   Ú
make_aliasz"define_aliases.<locals>.make_aliasõ   sA   øø€ Ý	Œ  dÑ+Ô+Ñ	,Ô	,ð	8ð 	8ð 	8ð 	8ñ 
-Ô	,ð	8àˆ
r   F)Úget_Úset_Tz
Alias for `z`.z%Neither getter nor setter exists for c                 óF   — h | £d„ |                       ¦   «         D ¦   «         £S )Nc              3   ó$   K  — | ]
}|D ]}|V — Œ Œd S r   r'   )r*   Ú aliasesÚaliass      r   r-   zBdefine_aliases.<locals>.get_aliased_and_aliases.<locals>.<genexpr>
  s/   è è € ÐKÐK  À7ÐKÐK¸%eÐKÐKÐKÐKÐKÐKÐKr   )rK   )Úds    r   Úget_aliased_and_aliasesz/define_aliases.<locals>.get_aliased_and_aliases	  s)   € ØLÐLÐKÐK¨1¯8ª8©:¬:ÐKÑKÔKÐLÐLr   Ú
_alias_mapz2Parent class already defines conflicting aliases: )rx   Ú partialÚdefine_aliasesr8   rw   r"   r%   Ú setattrr   r~   ÚNotImplementedErrorr‹   )Ú alias_dru   r‚   rq   r‡   ÚexistsÚprefixrˆ   r€   rŠ   Úpreexisting_aliasesÚ
conflictings    `          r   r   r   à   s™  ø€ ð$ 
€{ÝÔ ¥°Ñ9Ô9Ð9ðð ð ð ð ð !Ÿš™œð Bð B‰
ˆˆgØˆØ&ð  	9ð  	9ˆFØ˜‰}¥ S¡	¤	Ð)Ð)ØØ$ð 9ð 9EØ'˜Z¨°©
Ñ6Ô6FØ&,¨u¡nF”OØ%D°6¸D±=Ð%DÐ%DÐ%DF”NÝ˜C ¨%¡°Ñ8Ô8Ð8Ð8øØð 	BÝØ@¸Ð@Ð@ñBô Bð 
Bð	BðMð Mð Mõ " # |°RÑ8Ô8ÐØ*Ð*Ð+>Ñ?Ô?Ø,Ð,¨WÑ5Ô5ñ6€Kà ð På!ØNÀÐNÐNñPô Pð 	Pà7Ð+Ð7¨wÐ7€C„NØ
€Jr   c                 ó’   — t          | ¦  «        D ]6\  }}	  ||i |¤Žc S # t          $ r |t          | ¦  «        dz
  k    r‚ Y Œ3w xY wdS )a   
    Select and call the function that accepts ``*args, **kwargs``.

    *funcs* is a list of functions which should not raise any exception (other
    than `TypeError` if the arguments passed do not match their signature).

    `select_matching_signature` tries to call each of the functions in *funcs*
    with ``*args, **kwargs`` (in the order in which they are given).  Calls
    that fail with a `TypeError` are silently skipped.  As soon as a call
    succeeds, `select_matching_signature` returns its return value.  If no
    function accepts ``*args, **kwargs``, then the `TypeError` raised by the
    last failing call is re-raised.

    Callers should normally make sure that any ``*args, **kwargs`` can only
    bind a single *func* (to avoid any ambiguity), although this is not checked
    by `select_matching_signature`.

    Notes
    -----
    `select_matching_signature` is intended to help implementing
    signature-overloaded functions.  In general, such functions should be
    avoided, except for back-compatibility concerns.  A typical use pattern is
    ::

        def my_func(*args, **kwargs):
            params = select_matching_signature(
                [lambda old1, old2: locals(), lambda new: locals()],
                *args, **kwargs)
            if "old1" in params:
                warn_deprecated(...)
                old1, old2 = params.values()  # note that locals() is ordered.
            else:
                new, = params.values()
            # do things with params

    which allows *my_func* to be called either with two parameters (*old1* and
    *old2*) or a single one (*new*).  Note that the new signature is given
    last, so that callers get a `TypeError` corresponding to the new signature
    if the arguments they passed in do not match any signature.
    r   N)Ú	enumerater<   r>   )Úfuncsr   rA   rW   Úfuncs        r   Úselect_matching_signaturer™     s…   € õX ˜UÑ#Ô#ð ð ‰ ˆˆ4ð	Ø4˜Ð( Ð(Ð(Ð(Ð(Ð(øÝð 	ð 	ð 	Ø•C˜‘J”J ‘NÒ"Ð"Øð #Ð"ð	øøøð ð s   –   !AÁAc                 ó2   — t          | › d|› d|› d¦  «        S )zEGenerate a TypeError to be raised by function calls with wrong arity.z	() takes z positional arguments but z
 were given)r<   )rp   ÚtakesÚgivens      r   Ú
nargs_errorr   K  s>   € å
˜ð +ð + uð +ð +Øð+ð +ð +ñ ,ô ,ð ,r   c                 óŽ   — t          |t          ¦  «        st          t           |¦  «        ¦  «        }t	          | › d|› d¦  «        S )aL  
    Generate a TypeError to be raised by function calls with wrong kwarg.

    Parameters
    ----------
    name : str
        The name of the calling function.
    kw : str or Iterable[str]
        Either the invalid keyword argument name, or an iterable yielding
        invalid keyword arguments (e.g., a ``kwargs`` dict).
    z'() got an unexpected keyword argument 'ú')r6   rY   rZ   rb   r<   )rp   Úkws     r   Ú
kwarg_errorr¡   Q  sF   € õ b#Ñ
Ô
ð Ý
•$r‘(”(‰^Œ^ˆÝ
˜ÐJÐJÀRÐJÐJÐJÑ
KÔ
KÐKr   c              #   ój   K  — | V — |                       ¦   «         D ]}t          |¦  «        E d{V —† ŒdS )z8Yield *cls* and direct and indirect subclasses of *cls*.N)Ú__subclasses__Úrecursive_subclasses)ru   Úsubclss     r   r¤   r¤   b  sW   è è € à

€I€I€IØ×$Ò$Ñ&Ô&ð 0ð 0ˆÝ'¨Ñ/Ô/Ð/Ð/Ð/Ð/Ð/Ð/Ð/Ð/ð0ð 0r   c                 óØ  — i }t           j        dd…         dk    rLt          j        t          ¦  «        j        d         }t
          |dz
  ¦  «        t
          |dz
  ¦  «        f|d<   npt          j         ¦   «         }t          j	        d ¦  «        D ]G}|€ ||d<    n=t          j
        d	|j         
                    d
d
¦  «        ¦  «        s ||d<    n|j        }ŒH~t          j        | |fi |¤Ž dS )a4  
    `warnings.warn` wrapper that sets *stacklevel* to "outside Matplotlib".

    The original emitter of the warning can be obtained by patching this
    function back to `warnings.warn`, i.e. ``_api.warn_external =
    warnings.warn`` (or ``functools.partial(warnings.warn, stacklevel=2)``,
    etc.).
    Né   )é   é   Ú
matplotlibÚmpl_toolkitsÚskip_file_prefixesr   Ú
stacklevelz-\A(matplotlib|mpl_toolkits)(\Z|\.(?!tests\.))r"   Ú )ÚsysÚversion_infoÚ pathlibÚPathÚ__file__Ú parentsrY   Ú	_getframerc   re   ÚreÚmatchÚ	f_globalsÚgetÚf_backÚwarningsÚwarn)Ú messageÚcategoryrA   Ú basedirÚframer­   s         r   Ú
warn_externalrÁ   i  s
  € ð €FÝ 
Ô ˜˜˜Ô ˜wÒ &Ð &å”,xÑ(Ô(Ô0°Ô3ˆ Ý(+¨G°lÑ,BÑ(CÔ(CÝ(+¨G°nÑ,DÑ(EÔ(Eð(GˆÐ#Ñ$Ð$õ ”
‘”ˆÝ#œ/¨!Ñ,Ô,ð 
	!ð 
	!ˆJØˆ}à'1|Ñ$ØÝ”8ÐLà!œO×/Ò/°
¸BÑ?Ô?ñAô Að 
ð (2|Ñ$ØØ”LˆEˆEàÝ„M'˜8Ð.Ð. vÐ.Ð.Ð.Ð.Ð.r   r   )r%   rx   rc   r±   r¶   r¯   r»   Ú
deprecationr   r   r   r    r   r	   r
   r
   r   r   rE   rO   rh   rl   rz   r   r™   r   r¡   r¤   rÁ   r'   r   r   ú<module>rÃ      sµ  ðð
ð 
ð Ð Ð Ð Ø Ð Ð Ð Ø €€€Ø 	€	€	€	Ø 
€
€
€
Ø €€€ð"ð "ð "ð "ð "ð "ð "ð "ð "ð "ð "ð "ð "ð "ð "ð "ð "ð "ð "ð "ð "ð "ðð ð ð ð ñ ô ð ðJ )ð  )ð  )ðF 9=ð "ð "ð "ð "ð "ðB ð  ð  ðF:ð :ð :ð* ð  ð  ðF4ð 4ð 4ð 4ðn1ð 1ð 1ðh,ð ,ð ,ðLð Lð Lð"0ð 0ð 0ð/ð /ð /ð /ð /ð /r   
