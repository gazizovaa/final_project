Â§
    Â°quhÃ§5  Ã£                   Ã³ÃŒ   â€” d Z ddlZddlZddlZddlZddlZddlZddl mZm	Z	m
Z
m
Z
mZm
Z
mZmZmZ  G dâ€ dÂ¦  Â«        Zd â€ Zdd	Å“d
â€Zd
â€ Zdâ€ Zd
â€ Zddâ€Zdâ€ Zdâ€ Zdâ€ Zdâ€ Zddâ€ZdS )a+  
Helper functions for managing the Matplotlib API.

This documentation is only relevant for Matplotlib developers, not for users.

.. warning::

    This module and its submodules are for internal use only.  Do not use them
    in your own code.  We may change the API at any time with no warning.

Ã©    NÃ©   )	Ãš
deprecatedÃšwarn_deprecatedÃšrename_parameterÃšdelete_parameterÃšmake_keyword_onlyÃšdeprecate_method_overrideÃšdeprecate_privatize_attributeÃš'suppress_matplotlib_deprecation_warningÃšMatplotlibDeprecationWarningc                   Ã³6   â€” e Zd ZdZddâ€Zdâ€ Zedâ€ Â¦   Â«         Z dS ) Ãš
classpropertya$  
    Like `property`, but also triggers on access via the class, and it is the
    *class* that's passed as argument.

    Examples
    --------
    ::

        class C:
            @classproperty
            def foo(cls):
                return cls.__name__

        assert C.foo == "C"
    Nc                 Ã³d   â€” || _         |â‚¬|Ât          dÂ¦  Â«        â€š|| _        || _        || _        d S )Nz#classproperty only implements fget.)Ãš_fgetÃš
ValueErrorÃšfsetÃšfdelÃš_doc)ÃšselfÃšfgetr   r   Ãšdocs        ÃºCD:\streamlit_app\venv\Lib\site-packages\matplotlib/_api/__init__.pyÃš__init__zclassproperty.__init__-   s<   â‚¬ Ã˜Ë†Å’
Ã˜
Ã
ËœtÃ/ÃÃBÃ‘CÃ”CÃCÃ˜Ë†Å’	Ã˜Ë†Å’	Ã Ë†Å’	Ë†	Ë†	Ã³    c                 Ã³,   â€” | Â                      |Â¦  Â«        S Â©NÂ©r   )r   ÃšinstanceÃšowners      r   Ãš __get__zclassproperty.__get__6   s   â‚¬ Ã˜ÂzÅ zËœ%Ã‘ Ã” Ã r   c                 Ã³   â€” | j         S r   r   )r   s    r   r   zclassproperty.fget9   s
   â‚¬ Ã Å’zÃr   )NNN)Ãš__name__Ãš
__module__Ãš__qualname__Ãš __doc__r   r    Ãšpropertyr   Â© r   r   r   r      s\   â‚¬ â‚¬ â‚¬ â‚¬ â‚¬ Ã°Ã° Ã°  Ã°  Ã°  Ã°  Ã°!Ã° !Ã° !Ã° Ã°Ã° Ã± â€XÃ°Ã° Ã° r   r   c             
   Ã³l  â€¡â€” t          dÂ¦  Â«        Å t          | t           Â¦  Â«        r| fn| â‚¬â€°fnt          Ë†fdâ€| D Â¦   Â«         Â¦  Â«        } Ë†fdâ€}|Â                     Â¦   Â«         D ]Ã‘\  }}t          || Â¦  Â«        sÂ¼g t	          || Â¦  Â«        Â¢}d|v r*|Â                     dÂ¦  Â«         |Â                     dÂ¦  Â«         t          dÂ                     |t          |Â¦  Â«        dk    r)d Â 
                    |ddâ€¦         Â¦  Â«        d	z   |d         z   n |d
          |t          |Â¦  Â«        Â¦  Â«        Â¦  Â«        Â¦  Â«        â€šÅ’Ã’dS )
a3  
    For each *key, value* pair in *kwargs*, check that *value* is an instance
    of one of *types*; if not, raise an appropriate TypeError.

    As a special case, a ``None`` entry in *types* is treated as NoneType.

    Examples
    --------
    >>> _api.check_isinstance((SomeClass, None), arg=arg)
    Nc              3   Ã³$   â€¢K  â€” | ]
}|â‚¬â€°n|V â€” Å’
d S r   r'   )Ãš.0ÃštpÃš	none_types     â‚¬r   Ãº	<genexpr>z#check_isinstance.<locals>.<genexpr>O   s+   Ã¸Ã¨ Ã¨ â‚¬ ÃCÃCÂ°rÂ Â 
Â9Â9Â°ÃCÃCÃCÃCÃCÃCr   c                 Ã³V   â€¢â€” | â€°u rdn"| j         dk    r | j        n| j         â€º d| j        â€º ÂS )NÃšNoneÃšbuiltinsÃº.)r#   r$   )r+   r,   s    â‚¬r   Ãš	type_namez#check_isinstance.<locals>.type_nameQ   s=   Ã¸â‚¬ Ã˜Â 	Ëœ/Ëœ/ÂÂÃ˜(*Â¬
Â¸Ã’(CÃ(CÂRâ€_Â_Ã˜Å“
Ã9Ã9Â¨Â¬Ã9Ã9Ã°	;r   r/   z({!r} must be an instance of {}, not a {}r   Ãº, Ã©Ã¿Ã¿Ã¿Ã¿z or r   )
ÃštypeÃš
isinstanceÃštupleÃšitemsÃšmapÃšremoveÃšappendÃš	TypeErrorÃšformatÃšlenÃšjoin) ÃštypesÃškwargsr2   ÃškÃšvÃšnamesr,   s          @r   Ãšcheck_isinstancerE   A   sl  Ã¸â‚¬ Ãµ ÂTâ€˜
â€
â‚¬IÃ#Â EÂ­4Ã‘0Ã”0Ã° DË†eË†XË†XÃ˜"Ëœ]Ë†iË†\Ë†\Ã
ÃCÃCÃCÃCÂ¸UÃCÃ‘CÃ”CÃ‘
CÃ”
CÃ° 
Ã°;Ã° ;Ã° ;Ã° ;Ã° ;Ã°
 â€”â€™â€˜â€Ã° 
)Ã° 
)â€°Ë†Ë†1ÃËœ!ËœUÃ‘#Ã”#Ã° 
	)Ã˜,â€¢cËœ)Â UÃ‘+Ã”+Ã,Ë†EÃ˜ËœË†Ë†Ã˜â€”â€™ËœVÃ‘$Ã”$Ã$Ã˜â€”â€™ËœVÃ‘$Ã”$Ã$ÃÃ˜:Ã—AÃ’AÃ˜Ã¥Ëœ5â€˜zâ€zÂ Aâ€™~Â~Ã° â€”Iâ€™IËœeÂ CÂ RÂ CÅ“jÃ‘)Ã”)Â¨FÃ‘2Â°UÂ¸2Â´YÃ‘>Ã>Ã˜+0Â°Â¬8Ã˜ÂIÂdÂ 1â„¢gÅ“gÃ‘&Ã”&Ã±	(Ã´ (Ã±)Ã´ )Ã° 
)Ã°

	)Ã°
)Ã° 
)r   T)Ãš_print_supported_valuesc         	   
   Ã³Ã°   â€” |st          dÂ¦  Â«        â€š|Â                     Â¦   Â«         D ]O\  }}|| vrF|â€ºd|â€º Â}|r.|ddÂ                     t           t          | Â¦  Â«        Â¦  Â«        â€º Âz
  }t
          |Â¦  Â«        â€šÅ’PdS )ak  
    For each *key, value* pair in *kwargs*, check that *value* is in *values*;
    if not, raise an appropriate ValueError.

    Parameters
    ----------
    values : iterable
        Sequence of values to check on.
    _print_supported_values : bool, default: True
        Whether to print *values* when raising ValueError.
    **kwargs : dict
        *key, value* pairs as keyword arguments to find in *values*.

    Raises
    ------
    ValueError
        If any *value* in *kwargs* is not found in *values*.

    Examples
    --------
    >>> _api.check_in_list(["foo", "bar"], arg=arg, other_arg=other_arg)
    zNo argument to check!Ãº is not a valid value for Ãº; supported values are r3   N)r<   r8   r?   r9   Ãšreprr   )ÃšvaluesrF   rA   ÃškeyÃšvalÃšmsgs         r   Ãš
check_in_listrO   d   sÂ¡   â‚¬ Ã°. Ã° 1ÃÃ/Ã‘0Ã”0Ã0Ã˜â€”Lâ€™Lâ€˜Nâ€NÃ° "Ã° "â€°Ë†Ë†SÃ˜
ÂfÃ
Ã
Ã˜Ã;Ã;Â°cÃ;Ã;Ë†CÃ˜&Ã° 
PÃ˜ÃOÂ°Â·Â²Â½3Â½tÃ€VÃ‘;LÃ”;LÃ‘1MÃ”1MÃOÃOÃ‘OÂÃËœSâ€˜/â€/Ã!Ã°	 Ã°"Ã° "r   c          
   
   Ã³D  â€¡â€” |Â                      Â¦   Â«         D Â]\  }}|j        }t          |Â¦  Â«        t          | Â¦  Â«        k    s't           dâ€ t	          || Â¦  Â«        D Â¦   Â«         Â¦  Â«        rÂ´t
          t
          j         ddâ€ t
          j        Â¦   Â«         D Â¦   Â«         Â¦  Â«        Â¦  Â«        Å dÂ 	                    Ë†fdâ€| ddd â€¦         D Â¦   Â«         ddd â€¦         Â¦  Â«        }t          | Â¦  Â«        dk    r|d	z
  }t          |â€ºd
t          | Â¦  Â«        â€º d
|â€º d|j        â€º Â Â¦  Â«        â€šÂÅ’
dS )
aÂ¦  
    For each *key, value* pair in *kwargs*, check that *value* has the shape *shape*;
    if not, raise an appropriate ValueError.

    *None* in the shape is treated as a "free" size that can have any length.
    e.g. (None, 2) -> (N, 2)

    The values checked must be numpy arrays.

    Examples
    --------
    To check for (N, 2) shaped arrays

    >>> _api.check_shape((None, 2), arg=arg, other_arg=other_arg)
    c              3   Ã³0   K  â€” | ]\  }}||k    o|d uV â€” Å’d S r   r'   )r*   ÃšsÃšts      r   r-   zcheck_shape.<locals>.<genexpr>â„¢   s3   Ã¨ Ã¨ â‚¬ ÃSÃSÂ±DÂ°AÂ°qÂqËœAâ€™vÃ/Â !Â¨4Â -ÃSÃSÃSÃSÃSÃSr   Ãš NMLKJIHc              3   Ã³    K  â€” | ]	}d |â€º ÂV â€” Å’
dS )ÃšDNr'   )r*   Ãšis     r   r-   zcheck_shape.<locals>.<genexpr>Å“   s(   Ã¨ Ã¨ â‚¬ Ã4Ã4ËœQÂÂQÂÂÃ4Ã4Ã4Ã4Ã4Ã4r   r3   c                 Ã³P   â€¢â€” g | ]"}|Ât          |Â¦  Â«        nt          â€°Â¦  Â«        â€˜Å’#S r   )ÃšstrÃšnext)r*   ÃšnÃš
dim_labelss     â‚¬r   Ãº
<listcomp>zcheck_shape.<locals>.<listcomp>Â   s?   Ã¸â‚¬ Ã° $:Ã° $:Ã° $:Ã˜()Ã° /0Â¨mÂ¥CÂ¨Â¡FÂ¤FÂ FÃ…Ã€jÃ‘AQÃ”AQÃ° $:Ã° $:Ã° $:r   Nr4   r   Ãº,z	 must be zD with shape (z), but your input has shape )
r8   Ãšshaper>   ÃšanyÃšzipÃšiterÃš	itertoolsÃšchainÃšcountr?   r   ) r_   rA   rB   rC   Ãš
data_shapeÃš
text_shaper\   s          @r   Ãš
check_shaperh   â€¦   sj  Ã¸â‚¬ Ã°  â€”â€™â€˜â€Ã° Ã± â€°Ë†Ë†1Ã˜â€WË†
Ã¥Â
â€°OÅ’OÂsÂ 5â„¢zÅ“zÃ’)Ã)ÃÃSÃSÂ½CÃ€
ÃˆEÃ‘<RÃ”<RÃSÃ‘SÃ”SÃ‘SÃ”SÃ° 
*Ã¥ÂiÅ“oÃ˜Ã˜4Ã4Â¥)Â¤/Ã‘"3Ã”"3Ã4Ã‘4Ã”4Ã±6Ã´ 6Ã± 7Ã´ 7Ë†JÃ° Å¸Å¡Ã° $:Ã° $:Ã° $:Ã° $:Ã˜-2Â°4Â°4Â°RÂ°4Â¬[Ã°$:Ã± $:Ã´ $:Ã˜:>Â¸$Â¸BÂ¸$Ã´$@Ã± AÃ´ AË†JÃ¥Â5â€°zÅ’zËœQÅ Ë†Ã˜ËœcÃ‘!Â
Ã¥Ã˜Ã° 6Ã° 6Â¥Â UÂ¡Â¤Ã° 6Ã° 6Â¸:Ã° 6Ã° 6Ã˜,-Â¬GÃ°6Ã° 6Ã±Ã´ Ã° 
Ã± 
*Ã° Ã° r   c          
   
   Ã³"  â€” t          |Â¦  Â«        dk    rt          dÂ¦  Â«        â€š|Â                     Â¦   Â«         \  \  }}	 | |         S # t          $ r? t          |â€ºd|â€º ddÂ                     t
          t          | Â¦  Â«        Â¦  Â«        â€º ÂÂ¦  Â«        dâ€šw xY w) zÃ²
    *kwargs* must consist of a single *key, value* pair.  If *key* is in
    *mapping*, return ``mapping[value]``; else, raise an appropriate
    ValueError.

    Examples
    --------
    >>> _api.check_getitem({"foo": "bar"}, arg=arg)
    r   z-check_getitem takes a single keyword argumentrH   rI   r3   N) r>   r   r8   ÃšKeyErrorr?   r9   rJ   )Ãš mappingrA   rB   rC   s       r   Ãš
check_getitemrl   Â¨   sÂ²   â‚¬ Ãµ 
Ë†6Â{â€{ÂaÃ’ Ã ÃÃHÃ‘IÃ”IÃIÃ˜ÂlÅ lâ€°nÅ’nÂGÂFâ‚¬QË†Ã°:Ã˜ÂqÅ’zÃÃ¸Ã
Ã° :Ã° :Ã° :ÃÃ˜Ã° 
/Ã° 
/Â¨aÃ° 
/Ã° 
/Ã˜ÂyÅ yÂÂTÂ 7Ã‘+Ã”+Ã‘,Ã”,Ã°
/Ã° 
/Ã±0Ã´ 0Ã 59Ã°	:Ã°:Ã¸Ã¸Ã¸s   Â½ A ÃA	Bc                 Ã³Ã‚   â€¡ â€¡â€¡â€” â€° j         dk    sJ â€šdâ€ t          â€° Â¦  Â«        Â                     Â¦   Â«         D Â¦   Â«         Å  â€° Â¦   Â«         Å t          j        Ë† Ë†Ë†fdâ€Â¦   Â«         }|S )a
  
    Helper decorator for implementing module-level ``__getattr__`` as a class.

    This decorator must be used at the module toplevel as follows::

        @caching_module_getattr
        class __getattr__:  # The class *must* be named ``__getattr__``.
            @property  # Only properties are taken into account.
            def name(self): ...

    The ``__getattr__`` class will be replaced by a ``__getattr__``
    function such that trying to access ``name`` on the module will
    resolve the corresponding property (which may be decorated e.g. with
    ``_api.deprecated`` for deprecating module globals).  The properties are
    all implicitly cached.  Moreover, a suitable AttributeError is generated
    and raised if no property with the given name exists.
    Ãš
__getattr__c                 Ã³D   â€” i | ]\  }}t          |t          Â¦  Â«        Â¯||â€œÅ’S r'   )r6   r&   )r*   ÃšnameÃšprops      r   Ãº
<dictcomp>z*caching_module_getattr.<locals>.<dictcomp>Ã’   s<   â‚¬ Ã° 
,Ã° 
,Ã° 
,â„¢JËœDÂ $ÃËœ4Â¥Ã‘*Ã”*Ã°
,Ë†TÂ4Ã° 
,Ã° 
,Ã° 
,r   c                 Ã³v   â€¢â€” | â€°v râ€°|          Â                      â€°Â¦  Â«        S t          dâ€°j        â€ºd| â€ºÂÂ¦  Â«        â€š)Nz module z has no attribute )r    ÃšAttributeErrorr#   )rp   Ãšclsr   Ãšpropss    â‚¬â‚¬â‚¬r   rn   z+caching_module_getattr.<locals>.__getattr__Ã–   sN   Ã¸â‚¬ Ã 
Â5Ë†=Ë†=Ã˜Ëœâ€;Ã—&Ã’&Â xÃ‘0Ã”0Ã0ÃÃ˜BÂcâ€nÃBÃBÂ¸$ÃBÃBÃ±DÃ´ DÃ° 	Dr   )r"   Ãšvarsr8   Ãš	functoolsÃšcache)ru   rn   r   rv   s   ` @@r   Ãšcaching_module_getattrrz   Â½   sÂ   Ã¸Ã¸Ã¸â‚¬ Ã°& Å’<Ëœ=Ã’
(Ã
(Ã
(Ã
(Ã°
,Ã° 
,Â­$Â¨sÂ©)Â¬)Â¯/Âª/Ã‘*;Ã”*;Ã° 
,Ã± 
,Ã´ 
,â‚¬EÃ Ë†sâ€°uÅ’uâ‚¬HÃ¥â€_Ã°DÃ° DÃ° DÃ° DÃ° DÃ° DÃ± â€_Ã°DÃ° Ãr   c                 Ã³Ã²  â€¡â€” â€°â‚¬t          j        t          | Â¦  Â«        S Ë†fdâ€}| Â                     Â¦   Â«         D ]u\  }}d}dD ]W}||z   t	          â€°Â¦  Â«        v rAd}|D ]<}  |||z   Â¦  Â«        }|| z   |_        d||z   â€º d Â|_        t          â€°|| z   |Â¦  Â«         Å’=Å’X|st          d|â€ºÂÂ¦  Â«        â€šÅ’vd	â€ }	t          â€°d
i Â¦  Â«        }
 |	|
Â¦  Â«         |	| Â¦  Â«        z  }
|
rt          d
|
â€º ÂÂ¦  Â«        â€ši |
Â¥| Â¥â€°_
        â€°S )aT  
    Class decorator for defining property aliases.

    Use as ::

        @_api.define_aliases({"property": ["alias", ...], ...})
        class C: ...

    For each property, if the corresponding ``get_property`` is defined in the
    class so far, an alias named ``get_alias`` will be defined; the same will
    be done for setters.  If neither the getter nor the setter exists, an
    exception will be raised.

    The alias map is stored as the ``_alias_map`` attribute on the class and
    can be used by `.normalize_kwargs` (which assumes that higher priority
    aliases come last).
    Nc                 Ã³d   â€¢â€¡ â€” t          j        t          â€°â€° Â¦  Â«        Â¦  Â«        Ë† fdâ€Â¦   Â«         }|S )Nc                 Ã³0   â€¢â€”  t          | â€°Â¦  Â«        |i |Â¤Å½S r   )Ãš getattr)r   ÃšargsrA   rp   s      â‚¬r   Ãšmethodz2define_aliases.<locals>.make_alias.<locals>.methodÃ¶   s"   Ã¸â‚¬ Ã &â€¢7Ëœ4Â Ã‘&Ã”&Â¨Ã7Â°Ã7Ã7Ã7r   )rx   Ãšwrapsr~   )rp   râ‚¬   ru   s   ` â‚¬r   Ãš
make_aliasz"define_aliases.<locals>.make_aliasÃµ   sA   Ã¸Ã¸â‚¬ Ã	Å’ÂÂ Â dÃ‘+Ã”+Ã‘	,Ã”	,Ã°	8Ã° 	8Ã° 	8Ã° 	8Ã± 
-Ã”	,Ã°	8Ã Ë†
r   F)Ãšget_Ãšset_Tz
Alias for `z`.z%Neither getter nor setter exists for c                 Ã³F   â€” h | Â£dâ€ | Â                      Â¦   Â«         D Â¦   Â«         Â£S )Nc              3   Ã³$   K  â€” | ]
}|D ]}|V â€” Å’ Å’d S r   r'   )r*   Ãš aliasesÃšaliass      r   r-   zBdefine_aliases.<locals>.get_aliased_and_aliases.<locals>.<genexpr>
  s/   Ã¨ Ã¨ â‚¬ ÃKÃKÂ  Ã€7ÃKÃKÂ¸%ÂeÃKÃKÃKÃKÃKÃKÃKr   )rK   )Ãšds    r   Ãšget_aliased_and_aliasesz/define_aliases.<locals>.get_aliased_and_aliases	  s)   â‚¬ Ã˜LÂÃLÃKÃKÂ¨1Â¯8Âª8Â©:Â¬:ÃKÃ‘KÃ”KÃLÃLr   Ãš
_alias_mapz2Parent class already defines conflicting aliases: )rx   Ãš partialÃšdefine_aliasesr8   rw   r"   r%   Ãš setattrr   r~   ÃšNotImplementedErrorrâ€¹   )Ãš alias_dru   râ€š   rq   râ€¡   ÃšexistsÃšprefixrË†   râ‚¬   rÅ    Ãšpreexisting_aliasesÃš
conflictings    `          r   rÂ   rÂ   Ã    sâ„¢  Ã¸â‚¬ Ã°$ 
â‚¬{ÃÃ” Â¥Â°Ã‘9Ã”9Ã9Ã°Ã° Ã° Ã° Ã° Ã° !Å¸Å¡â„¢Å“Ã° BÃ° Bâ€°
Ë†Ë†gÃ˜Ë†Ã˜&Ã°  	9Ã°  	9Ë†FÃ˜Ëœâ€°}Â¥Â SÂ¡	Â¤	Ã)Ã)Ã˜ÂÃ˜$Ã° 9Ã° 9ÂEÃ˜'ËœZÂ¨Â°Â©
Ã‘6Ã”6ÂFÃ˜&,Â¨uÂ¡nÂFâ€OÃ˜%DÂ°6Â¸DÂ±=Ã%DÃ%DÃ%DÂFâ€NÃËœCÂ Â¨%Â¡Â°Ã‘8Ã”8Ã8Ã8Ã¸Ã˜Ã° 	BÃÃ˜@Â¸Ã@Ã@Ã±BÃ´ BÃ° 
BÃ°	BÃ°MÃ° MÃ° MÃµ "Â #Â |Â°RÃ‘8Ã”8ÃÃ˜*Ã*Ã+>Ã‘?Ã”?Ã˜,Ã,Â¨WÃ‘5Ã”5Ã±6â‚¬KÃ  Ã° PÃ¥!Ã˜NÃ€ÃNÃNÃ±PÃ´ PÃ° 	PÃ 7Ã+Ã7Â¨wÃ7â‚¬Câ€NÃ˜
â‚¬Jr   c                 Ã³â€™   â€” t          | Â¦  Â«        D ]6\  }}	  ||i |Â¤Å½c S # t          $ r |t          | Â¦  Â«        dz
  k    râ€š Y Å’3w xY wdS )a   
    Select and call the function that accepts ``*args, **kwargs``.

    *funcs* is a list of functions which should not raise any exception (other
    than `TypeError` if the arguments passed do not match their signature).

    `select_matching_signature` tries to call each of the functions in *funcs*
    with ``*args, **kwargs`` (in the order in which they are given).  Calls
    that fail with a `TypeError` are silently skipped.  As soon as a call
    succeeds, `select_matching_signature` returns its return value.  If no
    function accepts ``*args, **kwargs``, then the `TypeError` raised by the
    last failing call is re-raised.

    Callers should normally make sure that any ``*args, **kwargs`` can only
    bind a single *func* (to avoid any ambiguity), although this is not checked
    by `select_matching_signature`.

    Notes
    -----
    `select_matching_signature` is intended to help implementing
    signature-overloaded functions.  In general, such functions should be
    avoided, except for back-compatibility concerns.  A typical use pattern is
    ::

        def my_func(*args, **kwargs):
            params = select_matching_signature(
                [lambda old1, old2: locals(), lambda new: locals()],
                *args, **kwargs)
            if "old1" in params:
                warn_deprecated(...)
                old1, old2 = params.values()  # note that locals() is ordered.
            else:
                new, = params.values()
            # do things with params

    which allows *my_func* to be called either with two parameters (*old1* and
    *old2*) or a single one (*new*).  Note that the new signature is given
    last, so that callers get a `TypeError` corresponding to the new signature
    if the arguments they passed in do not match any signature.
    r   N)Ãš	enumerater<   r>   )Ãšfuncsr   rA   rW   Ãšfuncs        r   Ãšselect_matching_signaturerâ„¢     sâ€¦   â‚¬ ÃµX ËœUÃ‘#Ã”#Ã° Ã° â€° Ë†Ë†4Ã°	Ã˜Â4ËœÃ(Â Ã(Ã(Ã(Ã(Ã(Ã¸ÃÃ° 	Ã° 	Ã° 	Ã˜â€¢CËœâ€˜Jâ€JÂ â€˜NÃ’"Ã"Ã˜Ã° #Ã"Ã°	Ã¸Ã¸Ã¸Ã° Ã° s   â€“  Â !AÃAc                 Ã³2   â€” t          | â€º d|â€º d|â€º dÂÂ¦  Â«        S )zEGenerate a TypeError to be raised by function calls with wrong arity.z	() takes z positional arguments but z
 were given)r<   )rp   ÃštakesÃšgivens      r   Ãš
nargs_errorrÂ   K  s>   â‚¬ Ã¥
ËœÃ° +Ã° +Â uÃ° +Ã° +Ã˜Ã°+Ã° +Ã° +Ã± ,Ã´ ,Ã° ,r   c                 Ã³Å½   â€” t          |t          Â¦  Â«        st          t           |Â¦  Â«        Â¦  Â«        }t	          | â€º d|â€º dÂÂ¦  Â«        S )aL  
    Generate a TypeError to be raised by function calls with wrong kwarg.

    Parameters
    ----------
    name : str
        The name of the calling function.
    kw : str or Iterable[str]
        Either the invalid keyword argument name, or an iterable yielding
        invalid keyword arguments (e.g., a ``kwargs`` dict).
    z'() got an unexpected keyword argument 'Ãº')r6   rY   rZ   rb   r<   )rp   Ãškws     r   Ãš
kwarg_errorrÂ¡   Q  sF   â‚¬ Ãµ ÂbÂ#Ã‘
Ã”
Ã° Ã
â€¢$Ârâ€˜(â€(â€°^Å’^Ë†Ã
ËœÃJÃJÃ€RÃJÃJÃJÃ‘
KÃ”
KÃKr   c              #   Ã³j   K  â€” | V â€” | Â                      Â¦   Â«         D ]}t          |Â¦  Â«        E d{V â€”â€  Å’dS )z8Yield *cls* and direct and indirect subclasses of *cls*.N)Ãš__subclasses__Ãšrecursive_subclasses)ru   Ãšsubclss     r   rÂ¤   rÂ¤   b  sW   Ã¨ Ã¨ â‚¬ Ã 

â‚¬Iâ‚¬Iâ‚¬IÃ˜Ã—$Ã’$Ã‘&Ã”&Ã° 0Ã° 0Ë†Ã'Â¨Ã‘/Ã”/Ã/Ã/Ã/Ã/Ã/Ã/Ã/Ã/Ã°0Ã° 0r   c                 Ã³Ã˜  â€” i }t           j        ddâ€¦         dk    rLt          j        t          Â¦  Â«        j        d         }t
          |dz
  Â¦  Â«        t
          |dz
  Â¦  Â«        f|d<   npt          j         Â¦   Â«         }t          j	        d Â¦  Â«        D ]G}|â‚¬ ||d<    n=t          j
        d	|j        Â 
                    d
d
Â¦  Â«        Â¦  Â«        s ||d<    n|j        }Å’H~t          j        | |fi |Â¤Å½ dS )a4  
    `warnings.warn` wrapper that sets *stacklevel* to "outside Matplotlib".

    The original emitter of the warning can be obtained by patching this
    function back to `warnings.warn`, i.e. ``_api.warn_external =
    warnings.warn`` (or ``functools.partial(warnings.warn, stacklevel=2)``,
    etc.).
    NÃ©   )Ã©   Ã©   Ãš
matplotlibÃšmpl_toolkitsÃšskip_file_prefixesr   Ãš
stacklevelz-\A(matplotlib|mpl_toolkits)(\Z|\.(?!tests\.))r"   Ãš )ÃšsysÃšversion_infoÃš pathlibÃšPathÃš__file__Ãš parentsrY   Ãš	_getframerc   re   ÃšreÃšmatchÃš	f_globalsÃšgetÃšf_backÃšwarningsÃšwarn)Ãš messageÃšcategoryrA   Ãš basedirÃšframerÂ­   s         r   Ãš
warn_externalrÃ   i  s
  â‚¬ Ã° â‚¬FÃ 
Ã” ËœËœËœÃ” ËœwÃ’ &Ã &Ã¥â€,ÂxÃ‘(Ã”(Ã”0Â°Ã”3Ë† Ã(+Â¨GÂ°lÃ‘,BÃ‘(CÃ”(CÃ(+Â¨GÂ°nÃ‘,DÃ‘(EÃ”(EÃ°(GË†Ã#Ã‘$Ã$Ãµ â€
â€˜â€Ë†Ã#Å“/Â¨!Ã‘,Ã”,Ã° 
	!Ã° 
	!Ë†JÃ˜Ë†}Ã '1ÂÂ|Ã‘$Ã˜ÂÃâ€8ÃLÃ !Å“OÃ—/Ã’/Â°
Â¸BÃ‘?Ã”?Ã±AÃ´ AÃ° 
Ã° (2ÂÂ|Ã‘$Ã˜ÂÃ˜â€LË†EË†EÃ Ãâ€MÂ'Ëœ8Ã.Ã.Â vÃ.Ã.Ã.Ã.Ã.r   r   )r%   rx   rc   rÂ±   rÂ¶   rÂ¯   rÂ»   Ãš
deprecationr   r   r   r    r   r	   r
   r
   r   r   rE   rO   rh   rl   rz   rÂ   râ„¢   rÂ   rÂ¡   rÂ¤   rÃ   r'   r   r   Ãº<module>rÃƒ      sÂµ  Ã°Ã°
Ã° 
Ã° Ã Ã Ã Ã˜ Ã Ã Ã Ã˜ â‚¬â‚¬â‚¬Ã˜ 	â‚¬	â‚¬	â‚¬	Ã˜ 
â‚¬
â‚¬
â‚¬
Ã˜ â‚¬â‚¬â‚¬Ã°"Ã° "Ã° "Ã° "Ã° "Ã° "Ã° "Ã° "Ã° "Ã° "Ã° "Ã° "Ã° "Ã° "Ã° "Ã° "Ã° "Ã° "Ã° "Ã° "Ã° "Ã° "Ã°Ã° Ã° Ã° Ã° Ã± Ã´ Ã° Ã°J )Ã°  )Ã°  )Ã°F 9=Ã° "Ã° "Ã° "Ã° "Ã° "Ã°B Ã°  Ã°  Ã°F:Ã° :Ã° :Ã°* Ã°  Ã°  Ã°F4Ã° 4Ã° 4Ã° 4Ã°n1Ã° 1Ã° 1Ã°h,Ã° ,Ã° ,Ã°LÃ° LÃ° LÃ°"0Ã° 0Ã° 0Ã°/Ã° /Ã° /Ã° /Ã° /Ã° /r   
